# 进程、线程、协程

## 什么是进程？

进程**是cpu分配资源的最小单位**；
**一个进程就是一个程序的运行实例**。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。

## 什么是线程？

线程 **是cpu调度的最小单位**；（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）

1. 进程中的任意一线程执行出错，都会导致整个进程的崩溃。
2. 线程之间共享进程中的数据。
3. 当一个进程关闭之后，操作系统会回收进程所占用的内存。
4. 进程之间的内容相互隔离。

## 什么是协程？

是一种比线程更加轻量级的存在，一个线程也可以拥有多个协程。协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。
最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。
 JavaScript 中协程是由一个生成器函数实现的。yield和next()方法就能不断的交出和恢复函数的执行权

## 扩展

> 引申到浏览器多进程，JS单线程事件循环，web worker

### 浏览器是多进程的

2007年以前浏览器都是单进程的
放在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。

最新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
![image](https://static001.geekbang.org/resource/image/b6/fc/b61cab529fa31301bde290813b4587fc.png)

如果打开了两个网站，通常情况下会是五个进程，但是有很多其他情况：
1:如果页面里有iframe的话，iframe也会运行在单独的进程中！
2:如果页面里有插件，同样插件也需要开启一个单独的进程！
3:如果你装了扩展的话，扩展也会占用进程
4:如果2个页面属于同一站点的话，并且从a页面中打开的b页面，那么他们会公用一个渲染进程

### 大家都在说js是单线程的，但是为什么要设计成单线程？

  这主要和js的用途有关，js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。

举个例子：**如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措**。

所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。
> 为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。

## 进程的通信方式

1. 管道,管道传输数据是单向的
2. FIFO，是一种文件类型；
3. 消息队列，是消息的链接表，存放在内核中；
4. 共享内存。
5. 信号量，是一个计数器；信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。
6. Socket,前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 Socket 通信了。

## CPU进程调度算法

> 一、先到先服务调度：
    二、最短作业优先调度：
    三、优先级调度：
    四、轮转调度：
    五、多级队列调度：
    六、多级反馈队列调度：

一、先到先服务调度：
First Come，First Served(FCFS)

定义：先请求CPU的进程首先分配到CPU。FCFS策略可以通过FIFO队列轻松实现。

护航效果：其他所有进程会等待一个大进程释放CPU

非抢占式：一旦CPU分配给了一个进程，该进程就会使用CPU知道释放CPU为止。

二、最短作业优先调度：
Short Job First （SJF）

定义：调度取决于进程的下次CPU执行长度，选择更短的作业优先执行。可以证明最短作业优先调度是最优的。

问题：SJF算法最难的是如何知道下次CPU执行的长度。可以将用户提交作业时指定的进程时限作为长度。但是在这种情况下用户会精确估计进程时间，来使得任务尽早执行。过小的值会引起时限超出错误，进而重新提交。所以SJF调度经常用于长期调度。
SJF算法也可能导致饥饿：长作业无限等待CPU。

抢占？：SJF算法可以是抢占的或者非抢占的，当一个新进程达到就绪队列而以前的进程正在执行时，如果新进程的下次CPU执行比当前运行进程的尚未完成的CPU执行还小，那么抢占SJF算法会抢占当前进程，非抢占SJF算法会允许当前运行进程完成执行。抢占SJF调度又称为最短剩余时间优先。

三、优先级调度：
priority scheduling

定义：每个进程都有一个优先级与其关联，具有最高优先级的进程先分配CPU，具有相同优先级的进程按FCFS调度。

（SJF调度可以看做是以作业长度的大小为优先级的优先级调度）

抢占？：优先级调度可以是抢占的或者非抢占的。

问题：低优先级的进程可能会无限等待CPU，称之为无穷阻塞或饥饿。解决的办法是老化：逐渐增加等待很长时间的进程的优先级。

四、轮转调度：
Round Robin （RR算法）

定义：轮转调度算法是专门为分时系统设计的。在FCFS的基础上增加了时间片以抢占切换进程。

RR策略的平均等待时间比较长。

RR调度算法是抢占式的。

问题：RR算法的性能很大程度取决于时间片的大小。时间片过大，RR算法和FCFS算法一样；过小，则导致大量的上下文切换。
上下文切换时间一般少于10ms，时间片一般设置为10~100ms。
根据经验，80%的CPU执行应该小于时间片。

五、多级队列调度：
多级队列算法允许多个不同算法用于不同类型的进程。定义不同优先级的队列，但是一个进程会被永久分配到一个队列。

例如：前台的任务更关心响应时间，因为前台任务是与用户直接进行交互的，需要快速响应用户的请求，所以前台队列使用RR算法；后台任务更关心周转时间，需要快速的结束任务的，可以使用FCFS或者SJF算法。

队列之间应有调度，通常采用固定的优先级抢占调度。如图，只有前台任务没有时才调度后台任务。
也可以在队列间划分时间片，如前台队列有80%的CPU时间，队列中进行RR调度；后台队列有20%的CPU时间，用FCFS或者SJF调度。

六、多级反馈队列调度：
允许进程在队列间切换。

如果一个进程消耗过多的CPU时间，将会被移动到更低的优先级队列，如果一个进程等待时间过久，会被移到更高优先级队列。
