# 设计模式

## 面向对象五个基本原则

单一功能原则（Single responsibility principle）规定
就一个类而言，应该**仅有一个引起它变化的原因。应该只有一个职责。**
所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。

## 单例模式

单例模式中Class的实例个数最多为1。当需要一个对象去贯穿整个系统执行某些任务时，单例模式就派上了用场。
隐藏Class的构造函数，避免多次实例化
通过暴露一个 getInstance() 方法来创建/获取唯一实例

## 工厂模式

工厂可以看成是一个制造其他对象的对象，制造出的对象也会随着传入工厂对象参数的不同而有所区别。

## 策略模式

对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。
最常见的使用策略模式的场景如登录鉴权，鉴权算法取决于用户的登录方式是手机、邮箱或者第三方的微信登录等等，而且登录方式也只有在运行时才能获取，获取到登录方式后再动态的配置鉴权策略。

## 代理模式

代理模式：为对象提供一个代用品或占位符，以便控制对它的访问

例如实现图片懒加载的功能，先通过一张loading图占位，然后通过异步的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面

## 中介者模式

中介者模式的定义：通过一个中介者对象，其他所有的相关对象都通过该中介者对象来通信，而不是相互引用，当其中的一个对象发生改变时，只需要通知中介者对象即可

通过中介者模式可以解除对象与对象之间的紧耦合关系

## 观察者模式

被观察对象（subject）维护一组观察者（observer），当被观察对象状态改变时，通过调用观察者的某个方法将这些变化通知到观察者。

## 装饰者模式

装饰者模式的定义：在不改变对象自身的基础上，在程序运行期间给对象动态地添加方法
