# TCP,UDP,IP

## IP：把数据包送达目的主机

计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。

## UDP：把数据包送达应用程序

“用户数据包协议（User Datagram Protocol）”，简称 UDP。
所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。

> 虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。

虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。
![image](https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190629165851878-1198531256.png)

## TCP：把数据完整地送达应用程序

**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议**。
相对于 UDP，TCP 有下面两个特点:
对于数据包丢失的情况，TCP 提供重传机制；
TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。
![image](https://img2018.cnblogs.com/blog/1290987/201906/1290987-20190615111551823-1173939851.png)

## 可靠性传输原理

TCP主要提供了`检验和`、`序列号/确认应答`、`超时重传`、`流量控制(滑动窗口)`、`拥塞控制`等方法实现了可靠性传输。(记住5种)
> 滑动窗口协议与自动重传请求技术结合形成连续ARQ协议，连续ARQ协议根据超时重发数据方式的不同分为后退N帧ARQ协议和选择重发ARQ协议。

### 1.检验和

TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

### 2.序列号/确认应答

* **什么是序列号？**
TCP会对每个字节的数据都进行编号，数据的编号就是数据的序列号，每个字节都有自己独一无二的编号，故序列号具有唯一性

* **序列号的作用？**
接收端为了区别重复的报文段（报文段也叫帧），接收端有时会收到很多重复的数据，那么TCP协议就需要能够识别出那些是重复的包，并且把重复的丢弃掉，此时就需要使用序列号，来实现去重

* **什么是确认应答机制**
收到一条报文后，向发送端发送一条确认ACK，此ACK的作用就是告诉发送端：接收端已经成功的收到了消息，并且希望收到下一条报文的序列号是什么

* **为什么需要确认应答机制**
在TCP连接成功后，发送的每一条数据都可能会丢失，因此需要确认应答，以保证数据的完整性

* **确认应答的作用**
1.来确认接收端收到数据了
2.可以知道收到的是哪一条数据

### 3.超时重传

当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
TCP为了保证无论在任何环境下都能比较高性能的通信，会动态的计算这个最大超时时间，所以超时时间不是确定的，是TCP动态的计算的
超时重传时间 RTO 的值应该略大于报文往返 RTT 的值
超时触发重传存在的问题是，超时周期可能相对较长。有没有一种机制可以减少超时重传的等待时间呢？于是 「快速重传」 机制应运而生
**快速重传**（Fast Retransmit）机制不以时间为驱动，而是以数据驱动重传。

快速重传机制的原理：每当接收方收到比期望序号大的失序报文段到达时，就向发送方发送一个冗余 ACK，指明下一个期待字节的序号。

### 4.流量控制

流量控制解决的是发送方和接收方速率不匹配的问题;
`接收方`通过告诉`发送方`自己接收缓冲区的大小，来使`发送方`控制发送的数据量。

接收端会在发送 ACK 确认应答报文时，将自己的即时窗口大小（接收窗口 rwnd）填入，并跟随 ACK 报文一起发送出去。而发送方根据接收到的 ACK 报文中的窗口大小的值改变自己的发送速度。如果接收到窗口大小的值为 0，那么发送方将停止发送数据。并定期地向接收端发送窗口探测数据段，提醒接收端把窗口大小告诉发送端。

#### 累积确认

假设窗口大小为 3 个 TCP 段，那么发送方就可以「连续发送」 3 个 TCP 段，并且中途即使有 ACK响应报文丢失，也可以通过「下一个确认应答进行确认」。

如下图：ACK 300 即使丢失了，也不会进行数据重发，可以通过下一个确认应答进行确认。只要发送方收到了 ACK 400 的确认应答，就意味着 400 之前的所有数据「接收方」都收到了。这个模式就叫**累积确认**或者**累积应答**。
![image](https://pic3.zhimg.com/80/v2-61957f3a61bc7ef342e6e39496bc010a_720w.jpg)

#### 滑动窗口

* 允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。
* 实现了TCP的流量控制，不至于发送太快导致太多的数据丢弃和重传。

窗口大小就是指无需等待确认应答，可以继续发送数据的最大值。
窗口的实现实际上是操作系统开辟的一个缓冲区，发送方在等待确认应答报文返回之前，必须在缓冲区中保留已发送的数据。如果在规定时间间隔内收到确认应答报文，就可以将数据从缓冲区中清除。

1. 发送方的窗口，下图就是发送方缓存的数据，根据处理的情况分成四个部分：

已发送并收到 ACK 确认应答的数据
已发送但未收到 ACK 确认应答的数据
未发送但总大小在接收方处理范围内的数据
未发送但总大小超过接收方处理范围的数据

![image](https://pic1.zhimg.com/80/v2-844ed69f04a53c75d04be1bfc98216cc_720w.jpg)
2. 接收方的滑动窗口
接收方的滑动窗口可分为三个部分：

已成功接收并确认的数据
未收到数据但可以接收的数据
未收到数据且不可以接收的数据（超出接收方窗口大小）
![image](https://pic1.zhimg.com/80/v2-48652862eeff25d1f86b51560a6fbc18_720w.jpg)

同样的，接收方的滑动窗口在成功接收并确认的数据后，窗口右移。

### 5.拥塞控制

拥塞控制解决的是避免网络资源被耗尽的问题。

> 当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。
流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度，防止过多的数据注入到网络中。

**拥塞窗口**是发送方维护的一个状态变量，它会根据网络的拥塞程度动态变化。
引入拥塞窗口cwnd后，发送窗口的大小就等于拥塞窗口和接收窗口的**最小值**。

拥塞控制的几个重要的概念：**慢启动、拥塞避免、快恢复、快重传**

无论是慢开始阶段还是拥塞避免，只要出现了网络拥塞（触发超时重传机制），慢开始轮限 sshresh 和 拥塞窗口大小 cwnd 的值会发生变化（乘法减小）：

ssthresh 设为 cwnd/2
cwnd 重置为 1
由于拥塞窗口大小重置为 1 了，所以就会重新开始执行慢启动算法。
![image](https://pic1.zhimg.com/80/v2-2b7564e5af3e189a137d50125231f50c_720w.jpg)

## 三次握手

第一次：客户端给服务端发送一个带有SYN标志的数据包 第二次：服务端给客户端发送带有SYN和ACK标志得数据包 第三次：客户端给服务端发送带有ACK标志的数据包

## 四次挥手

因为TCP是全双工通信的

（1）第一次挥手

因此当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

（2）第二次挥手

被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会**因为没有收到应答而继续发送断开连接的请求**（即FIN报文）。

（3）第三次挥手

被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。

（4）第四挥手

如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。（不然被动方不知道你收到没有就会一直重发）

参考文章
<https://codeantenna.com/a/dBg3Y29JWB>
<https://zhuanlan.zhihu.com/p/343398180>
