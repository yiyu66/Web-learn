# 装饰器Decorator

## 什么是装饰器？它的目的和类型

>装饰器是一种特殊的声明，可附加在类、方法、访问器、属性、参数声明上。

装饰器使用 @expression 的形式，其中 expression 必须能够演算为在运行时调用的函数，其中包括装饰声明信息。
它起到了以声明式方法将元信息添加至已有代码的作用。
装饰器类型及其执行优先级为

类装饰器——优先级 4 （对象实例化，静态）
方法装饰器——优先级 2 （对象实例化，静态）
访问器或属性装饰器——优先级 3 （对象实例化，静态）
参数装饰器——优先级 1 （对象实例化，静态）
注意，如果装饰器应用于类构造函数的参数，那么不同装饰器的优先级为：1. 参数装饰器，2. 方法装饰器，3. 访问器或参数装饰器，4. 构造器参数装饰器，5. 类装饰器。

```ts
@classDecorator
class TargetClass { // 类
  @fieldDecorator
  targetField = 0; // 类实例属性

  @funDecorator
  targetFun() { } // 类方法

  @accessorDecorator
  get targetGetFun() { } // 类访问器
}

```

## 装饰者模式

装饰者模式就是能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。打个比方，一个人在天气冷的时候要穿棉衣，天气热的时候穿短袖，可无论穿什么，本质上他还是一个人，只不过身上穿了不同的衣服。

所以简单来说， Decorator 就是一种动态地往一个类中添加新的行为的设计模式， 它可以在类运行时， 扩展一个类的功能， 并且去修改类本身的属性和方法， 使其可以在不同类之间更灵活的共用一些属性和方法。

@ 是针对这种设计模式的一个语法糖，不过目前还处于第 2 阶段提案中，使用它之前需要使用 Babel 模块编译成 ES5 或 ES6。
怎么使用装饰器

链接：<https://juejin.cn/post/7072883925764276254>
