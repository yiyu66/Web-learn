# 回流重绘与优化

## 浏览器渲染原理

HTML/SVG/XHTML 解析提供的html文件会产生一个 DOM Tree。

CSS 解析CSS会生成一个CSS Rule Tree

在渲染阶段，浏览器会把 DOM Tree 和 CSS Rule Tree 进行一个结合，生成一个最终的 DOM Tree并赋予每个树节点样式，生成 Render Tree

布局 Render Tree（layout/reflow），绘制各元素尺寸、位置计算

绘制 Render Tree （paint），绘制页面像素信息

将计算好的信息发送给 GPU 并显示在屏幕上

![image](https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210929_7a518978-2105-11ec-b34e-00163e068ecd.png)

## 回流 重绘

* **重绘**：当 Render tree 中的一些元素需要更新属性，而这些属性只影响到元素的外观（例如颜色）而不会影响到整体布局

* **回流**：当 Render Tree 中的一部分（或全部）元素因为规模、尺寸等等其他因素而改变时则需要重新构建 DOM Tree

从上文可以看出，回流必定发生重绘，而重绘不一定会引发回流。由此可以推断，回流所带来的成本是非常高的，如果频繁触发回流操作，那势必会造成页面的卡顿。已知下列操作都会导致回流和重绘：

* 页面第一次渲染(初始化)

* 添加或删除可见的 DOM 元素

* 元素的位置发生变化

* 元素的尺寸发生变化(包括外边距，内边距，边框大小，高度和宽度等）

* 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代或者字体改变

* 浏览器窗口尺寸的变化（因为回流是根据视口的大小来计算元素的位置和大小的）

* 定位或者浮动，盒模型等

## 优化

当然，由于每次重排都会造成巨大的性能消耗，大多数浏览器本身会实现一个队列去记录每次重排的动作，当队列中的动作达到一定的阈值或是经过一定的时间后会批量清空队列并进行一次重排，这样就会让原本多次的重排**压缩成一次处理**。

但是凡事没有绝对，当出现**获取布局信息的操作**时（这里可以理解为用户的某些行为需要看到浏览器页面的直接反馈效果），会立即刷新该队列的刷新并触发重排：

offsetTop, offsetLeft, offsetWidth, offsetHeight（获取元素位置信息）

scrollTop, scrollLeft, scrollWidth, scrollHeight（溢出类元素的滚动条操作）

clientTop, clientLeft, clientWidth, clientHeight（获取滚动条偏移量）

getComputedStyle()

getBoundingClientRect()

## 虚拟滚动-长列表优化

对于`scroll event`（滚动事件）,如果有大量列表要渲染，就可能会大量重排。

* 无法一次性渲染太多的 DOM 元素

* 每一次滚动事件将会让对应 DOM 中的所有元素重新渲染

### 数据分页

一次性渲染固定行数和列数的数据量，缺点是怕一次性的量就逼近上限。

### 无线滚动

无限滚动的方案是想看更多数据的时候再继续渲染，不看就不渲染避免性能浪费，但缺点就在于只要一直触发“继续看”的操作，那么之前遗留的数据将会越来越多导致性能雪崩。

### 虚拟滚动

既然在有限的视窗中我们只能看到一部分的数据，那么我们就通过计算可视范围内的单元格，这样就保证了每一次拖动，我们渲染的 DOM 元素始终是可控的，不会像数据分页方案怕一次性渲染过多，也不会发生无限滚动方案中的老数据堆积现象。
![image](https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20210929_7b319360-2105-11ec-b34e-00163e068ecd.png)

### 实现

每一行的高度需要相同，方便计算

需要得知渲染的数据量（数组长度），可基于总量和每个元素的高度计算出容器整体的所需高度，这样就可以伪造一个真实的滚动条

获取可视区域的高度

在滚动事件触发后，滚动条的距顶距离也可以理解为这个数据量中的偏移量，再根据可视区域本身的高度，算出本次偏移的截止量，这样就得到了需要渲染的具体数据

如果类似于渲染一个宽表，单行可横向拆分为多列，那么在X轴上同理实现一次，就可以横向的虚拟滚动

<https://www.modb.pro/db/122781>
